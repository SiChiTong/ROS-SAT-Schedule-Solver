\documentclass{article}
\title{Optimal Dub-E Scheduling}
\author{Skyler Peterson, Alex Sanchez-Stern}

\begin{document}
\maketitle
\section{Introduction}
For our final project,
we decided to look to robotics
for problems that SMT might be able to tackle.
Since we are fortunate enough to be at a school
where there is always interesting work going on across fields,
we didn't have to look far.
We contacted Michael Jae-Yoon Chung and Andrzej Pronobis,
who are working on the Semantics Aware Robotic Assistant,
more commonly known as DUB-E.
DUB-E is able to traverse the CSE building,
and accomplish tasks for it's users,
such as checking whether a particular professor is in their office.
DUB-E is controlled via a web interface,
from which users can request that certain tasks be accomplished,
by a particular deadline.

Unfortunately, when deadlines are short
and there are many tasks to accomplish,
it is non-trivial to decide what task
should be accomplished when.
Additionally, the expressive power of the interface to DUB-E
is currently limited;
Users can specify a tasks deadline,
but cannot specify more precise timing information,
such as a time in the future
before which the task should not be done,
or multiple time periods in which a task can be accomplished.

Handling these new scheduling concerns
requires a more sophisticated scheduling algorithm
than the one that was previously implemented in DUB-E.
We implemented this new scheduling algorithm
by encoding the scheduling constraints into SMT,
and then using Z3 as a backend
to solve the constraints.
The result is a schedule which instructs DUB-E
when to tackle each task and,
in some cases,
how long to wait in between tasks.
\section{Overview}
DUB-E's overall behavior is quite simple.
It is notified of new tasks via the web interface,
and it's scheduler decides what tasks to do when.
Each time it receives a new task,
it can change how it schedules it's current tasks.
Tasks which are completed are removed from it's schedule,
but not all tasks get completed.
If DUB-E is overscheduled,
it may not have enough time to complete a requested task in time.
Additionally, the travel time of DUB-E
is not entirely predictable.
While it's travel time between two locations
can mostly be bounded within a range,
it is always possible that it will completely fail,
and take much longer to reset itself
and become fully operational again.

The previous scheduling algorithm
for DUB-E was quite simple.
DUB-E simple maintained a FIFO queue
upon which it's tasks resided.
New requests made via the web interface
are added to the end of the queue,
and when DUB-E is not currently working on a task,
it pulls the next task from the front of the queue.
When DUB-E pulls a task from the queue
whose deadline has already passed,
it notifies the user that it was unable to complete the task,
and drops it from the queue.
While simple and fair,
this algorithm fails to provide
optimal behavior in a variety of simple scenarios.

Consider the case where user one
requests that DUB-E go the kitchen
and check for food
within the next thirty five minutes.
Let's assume that it takes DUB-E fifteen minutes
to complete this task,
ten minutes to go to the kitchen,
five to check for food.
The, user two requests that DUB-E
check whether Emina Torlak is in her office,
within the next twenty minutes.
It takes again, fifteen minutes total
for DUB-E to complete the task,
ten to arrive at Emina's office,
and five to confirm whether or not she is there.
If DUB-E addresses the tasks in a first come, first serve order,
as the old scheduler would do,
by the time it had finished checking for food,
it would have missed the deadline for finding Emina.
If instead it had reordered the tasks,
checking for Emina first,
it would be able to accomplish both tasks on time.

The DUB-E scheduling problem is not simply
a classic instance of scheduling
where each task takes a fixed amount of time.
Consider the case where DUB-E
is requested to check for both Emina and Zach Tatlock
in their respective offices.
It might be the case that both requests
should be completed in 18 minutes.
If DUB-E is in another part of the building,
it might take five minutes to get to both offices,
and take five minutes to check them.
Taken seperately, each request takes ten minutes,
and it is not possible to do both,
since it would take twenty minutes to do both individually.
But Zach's and Emina's offices are only a minute apart,
both being on the fifth floor,
it actually is possible to complete both tasks,
since one can go to one office, complete the task,
and travel to the other one,
in only eleven minutes.
Completing the second task takes a further five minutes,
for a total time of sixteen minutes,
well within the deadline.

It is clear from this example that
a proper scheduling algorithm must consider spatial factors,
as well as temporal ones.
And while the above are fairly simple examples,
in the presence of multiple intervals
and complex task interactions,
the scheduling problem becomes quite complex.
\section{Scheduler Encoding}

\section{Results}

\section{Project Division}
We roughly divided the work into the encoding,
and the interface with DUB-E.
Skyler handled the interface with the robot,
setting up ROS nodes and working with Michael and Andrzej
to get the encoder integrated
into the DUB-E codebase.
Alex handled the actual encoding of the task constraints,
setting up the Z3 bindings to interface with the code,
and writing modules to take in task information,
encode it into a set of Z3 constraints,
decode the Z3 output into a schedule,
and format the schedule for DUB-E.

\section{Applied Topics}
This project involved mostly topics
that we discussed at the beginning of the quarter,
although it of course was supported by
the work we did throughout the quarter.
Specifically, the work on encoding different types of constraints
into conjunctive normal form was paramount to the project.
The encoding also made heavy use of MaxSAT,
which we touched on in class,
to satisfy the greatest number of tasks
in cases where not all tasks could be satisfied.
\end{document}
